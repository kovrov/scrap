generic
	point
	size
	rect
	tree
	vect
ui
	widgets
		...
	targetnode
	findControl
sys
	eventmanager
	window

--------------------------------------------------------------------------------

[SYS]
window_gdi
	win_proc
		on_paint { UI.event_mgr.paint(hwnd) }

[GDI]
template widget_1_paint()
{
	override void paint(hwnd)
}
draw_widget(UI.widget_2, hwnd)
draw_widget(UI.widget_3, hwnd)
draw_widget(UI.widget_4, hwnd)

[UI]
event_mgr
	paint(hwnd)
		foreach target_node
			GDI.draw_widget(target_node, hwnd)
target_node

[WIDGETS]
UI.target_node
	widget_1 [PAINT_FN]
	widget_2 [PAINT_FN]
	widget_3 [PAINT_FN]
	widget_4 [PAINT_FN]

[TEST]
	widget_1 ![GDI.draw_widget]
	widget_2 ![GDI.draw_widget]
	widget_3 ![GDI.draw_widget]
	widget_4 ![GDI.draw_widget]

--------------------------------------------------------------------------------

[sys]
	gdi_window<>

[ui]
	io_mgr<>
	target_node<>
		... widgets

[gdi]
	paint_code

[test]
	sys.gdi_win!<ui.io_mgr!<ui.target_node!<gdi.paint_code>>>

--------------------------------------------------------------------------------

[activatable]

What the point of being "activatable"?

* to show where is the focus (decorate "active" node with special style)
* to manipulate focus upon activation (restore focus state, possibly to none)
* to manipulate focus upon de-activation (remove focus state from child node, if any)

facts:
* Active node is a parent of a focused node
* If there is an Active node, global focus must be inside or no focus at all.
* Active and Focused states are closely related
* Active state must never conflict with Focused state
* Focused state prevails
* Active and Focused concepts have completely different purposes
  - "Activness" is logical concept of UI (for convenience and usability)
  - "Focusness" is fundation of input machinery
* Change of Z-order is a "side effect" of Activation, not purpose.

conclusions:
* Focus event may result in Activation either of self or parent node.
* Activation could happen as result of focus event or programically.
* Activatable node must be Focusable node as well.
* Activatable have zero or one "Active Focusable" child node.
* if activated programically ...
* if activated by focus event of focusable child node ...
* if activated by focus event of non-focusable child node ...

implementation:
* Activatable interface inherits from Focusable interface
* Upon logical activation node have to register it self with an Activateble parent as "Active Focusable"
* Active state of any Activatable node colud be checked by ...
* node activated by receiving focus event
* node activated by intercepting child focus event
